# 解题心得、套路


## 总体思路

逐个方法考虑

低性能,易实现  ->  高性能,难实现

- 暴力枚举(枚举可能空间,然后取取最值)
- O(n) 法, 总有办法遍历一次就可以,要有信念; 可以从头到尾; 也可以首尾向内, 或者双指针开始(例如滑动窗口)
- 动态规划
- 二分法(分治是更高维度的思路, 子组可以应用别的算法)

## 算法性能优化

- 预处理
- 空间换时间
- 位运算
- 数学定理,公式
- 省略

- 少改变数组,对象 i.e Array.pop ...
- 少变量
- 位运算(不能为了性能牺牲可读性)
- 少递归
- 少用对象的方法 i.e Array.prototype Object.prototype

找东西,用表,用索引


## 暴力枚举

给出所有可能的情况,取最值

通常,暴力法都是低效的,因而需要考虑如何提升效率,

想办法**删减可能空间**

存在多个影响因素时, 如果有些因素线性的,例如index, 可以在遍历该因素时, 对其他因素做局部线性处理(排序,比大小)
- [盛最多水的容器](/solution/02.medium/11.container-with-most-water.md)



## 递归

对于任意递归形式的问题, 可以从**结果**向最初递归, 也可以由**最初**向结果构建


BFS
将当前状态下,所有的下一步操作作为递归入口

- [22. 括号生成](/solution/02.medium/22.generate-parentheses.md)

DFS

## 分治

分治三步走, 基准, 分开, 合成

分开要选择对立的几种情况, 一定要选择到对立的情况才能得出正确解

例如, 最大子串问题, 分开对立的就是, 左, 中, 右; 环的分开对立就是, 考虑"首"不考虑"尾" 与 考虑"尾"不考虑"首"

----

## 各类型的解法

### number

- 改变数字排序, 尽量使用运算, 而不是变成字符串来处理; (是否提速有待考证...)

---
### String

- 优先考虑正则
- 字符串读取的问题, 考虑用 状态机

---
### Array

可排序数组

- 可以先排序再处理, 要注意不不一定数字才能排序, 字符也可以
- 遍历可以考虑跳过无用的值, 从而提速

不可排序数组

环, 需要拆环, 分成两种情况, 有首无尾, 有尾无首

#### 滑动窗口:

- [最大无重复子串](/solution/03.hard/03.longest-substring-without-repeating-characters.md)
#### 链表

哨兵节点, 用于抛弃

#### 动态规划

递归 + 缓存, 更进一步地将递归改为迭代;

适用的场景: 问题的解与问题的规模有关, 可以递推计算, 由上一个规模以及当前状态, 计算出解. 像分治的思维

分步走
1. 状态定义: dp[i] 表示什么意思
2. 初始状态: dp[0] = ?
3. 状态转移函数:  f(n) = g(f(n-1)); 考虑如何用 n-1 构建 n, 考虑 n-1 可以分成 p + q = n - 1 两部分来构建
4. 解: dp 列表中的最值

- [22. 括号生成](/solution/02.medium/22.generate-parentheses.md)
- [213. 打家劫舍2](/solution/02.medium/213.house-robber-2.md)


---


