# 2. 打家劫舍2

[leetcode](https://leetcode-cn.com/problems/house-robber-ii/)

## Solution

就是环形链表,取间隔节点,不限定隔1个,之和最大值


###

该问题要整体考虑全部节点再确定如何选择节点

```ts

// 暴力, 找出所有间隔组合, 取最大值
// DFS, 携带下一次的状态

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  const len = nums.length
  // 开头特殊处理
  if (len < 4) {
    const [a, b, c] = nums
    return Math.max(a, b || 0, c || 0)
  }
  if (len === 4) {
    const [a, b, c, d] = nums
    return Math.max(a + c, b + d)
  }
  const i0 = iter(0, nums, true)
  const i1 = iter(1, nums)
  const i2 = iter(2, nums)
  return Math.max(i0, i1, i2)
};
var cache = {}

/** @param {number[]} nums */
var iter = function (i, nums, noLast = false) {
  if (cache[i + "" + noLast]) { return cache[i + "" + noLast] }
  const last = nums.length - 1
  if (i + 2 > last) {
    return nums[i]
  }
  if (i + 2 === last) {
    return noLast
      ? nums[i]
      : nums[i + 2] + nums[i]
  }
  if (i + 3 === last) {
    if (noLast) {
      return nums[i + 2] + nums[i]
    }
    return nums[i + 2] >= nums[i + 3]
      ? nums[i + 2] + nums[i]
      : nums[i + 3] + nums[i]
  }

  const a = iter(i + 2, nums, noLast)
  const b = iter(i + 3, nums, noLast)
  const ret = Math.max(a, b) + nums[i]
  cache[i + "" + noLast] = ret
  return ret
}
```

leetcode 用了 cache 就执行不正确, 不用缓存就超时了..


### 动态规划

```js


```